---
title: "Homework 5 - Sampler Potpourri"
author: "Andrew Wong, Dipesh Gautam, Heather Shapiro, Siyang Li"
date: "11/23/2014"
output: html_document
---
### Introduction
The goal of homework 5 is to learn how to implement univariate sampling functions from random probability density functions. The steps to solving this problem involved first understanding the algorithm involved, coding the samplers, then optimizing them for speed and accuracy.

### Rejection Sampler
The rejection sampler first checks that the arguments for each parameter are of the correct type, e.g. sample size, *n* is a positive integer. 

The rejection sampler had good accuracy.

### Metropolis-Hastings Sampler

### Slice Sampler
For slice sampling, we adopted the stepping-out method for finding out the interval. We step out on both direction with width w from x0 until both ends are just outside the slice. Then, we sample x1 from this range, rejecting x1 if it's sampled outside the slide and reassigning the x1 as the boundary of interval on appropriate side.

We also noticed that using multiple cores was not efficient for lower sample size due to associated overhead in breaking up and combining the data. Due to this fact, we assigned multi-core implementation only when sample-size was greater than 1000.

We noticed that our score for slice sampler was on par with the score for R's built-in samplers and even better than our implementation of R's truncated normal sampling using package "truncnorm".
We were able to get good accuracy accross the board but as expected our implementation turned out to be slower. The speeds improved greatly with the multi core implementation and we were able to get much closer times to R's built-in samplers.


### R Sampler

```{r, echo=FALSE}
loadRDS("table.Rdata")
```