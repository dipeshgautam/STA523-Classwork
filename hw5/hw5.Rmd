---
title: "Homework 5 - Sampler Potpourri"
author: "Andrew Wong, Dipesh Gautam, Heather Shapiro, Siyang Li"
date: "11/23/2014"
output: html_document
---

## Introduction
The goal of homework 5 is to learn how to implement univariate sampling functions from random probability density functions. The steps to solving this problem involved first understanding the algorithm involved, coding the samplers, then optimizing them for speed and accuracy.

## Sampling Methodologies
### Rejection Sampler
The rejection sampler first checks that the arguments for each parameter are of the correct type, e.g. sample size, *n* is a positive integer. Next, the absolute max for the desired arbitrary function is determined to set the maximum height for the instrumental/proposal distribution 

The rejection sampler had good accuracy. 

### Metropolis-Hastings Sampler

### Slice Sampler
For slice sampling, we adopted the stepping-out method for finding out the interval. We step out on both direction with width w from x0 until both ends are just outside the slice. Then, we sample x1 from this range, rejecting x1 if it's sampled outside the slide and reassigning the x1 as the boundary of interval on appropriate side.

We also noticed that using multiple cores was not efficient for lower sample size due to associated overhead in breaking up and combining the data. Due to this fact, we assigned multi-core implementation only when sample-size was greater than 1000.

We noticed that our score for slice sampler was on par with the score for R's built-in samplers and even better than our implementation of R's truncated normal sampling using package "truncnorm".
We were able to get good accuracy accross the board but as expected our implementation turned out to be slower. The speeds improved greatly with the multi core implementation and we were able to get much closer times to R's built-in samplers.


### R Sampler


## Results
We ran the four samplers for the given six distributions and recorded the result in the table below. We have time/samples timing across all the samplers and distributions for n=10, 10,000, 1,000,000 and 10,000,000. We also record score for each sampler and distribution combination with 1,000,000 samples. All these tests were done both for single core and multi-core implementations of our samplers.
```{r results="asis", echo=FALSE}
source("check_packages.R")
suppressMessages(check_packages(c('xtable')))
table = readRDS("table.Rdata")
table.xtable = xtable(table)
display(table.xtable)= c("d", "s","s", "e", "e","e", "e","e", "e","e", "e","e", "e")
print(table.xtable, type="html")
```




