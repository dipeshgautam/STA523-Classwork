---
title: "Homework 5 - Sampler Potpourri"
author: "Andrew Wong, Dipesh Gautam, Heather Shapiro, Siyang Li"
date: "11/22/2014"
output: html_document
---
### Introduction
The goal of homework 5 is to learn how to implement univariate sampling functions from random probability density functions. The steps to solving this problem involved first understanding the algorithm involved, coding the samplers, then optimizing them for speed and accuracy.

### Rejection Sampler
The rejection sampler first checks that the arguments for each parameter are of the correct type, e.g. sample size, *n* is a positive integer. 
```{r loadTestFcts, echo = FALSE}
library(devtools) # Give source_url().
suppressMessages( # Load check_packages().
  source_url("https://raw.githubusercontent.com/aw236/r.functions/master/functions.R")) 
suppressMessages(check_packages(c("parallel", "xtable")))

reject <- function(n, dfunc, range, mc = FALSE) {
  # n = samples
  # dfunc = density function
  # range = numeric vector defining the min & max range of the pdf (e.g.: range = c(0, 1) )
  # Used for the vector of quantiles: x <- seq(range[1], range[2], length = n))
  # mc = multicore
  ## Use multiple cores?
  if (mc == TRUE & n >= 1000000) {
    mc.cores = 8 # Use 8 instead of detectCores()/2 because using a shared resource. 
  }
  
  ## Check Conditions
  stopifnot(is.numeric(n) && n%%1==0) # Ensure number of samples, n, is numeric and an integer.
  stopifnot(is.function(dfunc))
  stopifnot(is.vector(range))
  stopifnot(is.logical(mc))
  
  ## Initialize variables
  M <- min(100, max(dfunc(seq(range[1], range[2], length = 1e6)))) # Find the absolute max for the function.
  samples.uniform <- NULL # Create NULL list to store accepted proposal values under function's pdf.
  
  ## Visualization of rejection sampler.
  xseq <- seq(from = range[1], to = range[2], by = 0.01)
  plot(xseq, dfunc(xseq), type = "l", col = "blue")
  lines(xseq, M*dunif(xseq, range[1], range[2]), col = "red")
  
  ## Rejection sampler
  sample <- function (n, dfunc, range) {
    for (i in 1:n) {
      ## Vectorize. 
      proposal_x <- runif(1, min = range[1], max = range[2]) # Generate 1 proposal value for x within range.
      proposal_y <- runif(1, min = 0, max = M) # Generate 1 y-value for threshold of y.    
      if (dfunc(proposal_x) > proposal_y)
        samples.uniform <- c(samples.uniform, proposal_x) # If u < f(x) / M*g(x), then accept x as realization of f(x). Else, reject x and sample again.
    }
    return(samples.uniform)
  }
  
  ## Use-case for multi-core
  if (mc == TRUE && n > 1000){
    cores = 8 # Suggested by Dr. Rundel since we are using a shared resource.
    return(unlist(mclapply(1:cores, function(x) sample(ceiling(n/cores), dfunc, range),
                           mc.cores = cores) ) )
  }
  else{
    sample(n, dfunc, range)
  }
}

dbetann = function(x)
{
  dbeta(x,0.9,0.9)
}

dtnorm = function(x)
{
  ifelse(x < -3 | x > 3, 0, dnorm(x)/0.9973002)
}

dtexp = function(x)
{
  ifelse(x < 0 | x > 6, 0, dexp(x, rate=1/3)/0.8646647)
}

dunif_mix = function(x)
{
  ifelse(x >= -3 & x < -1, 0.6*dunif(x,-3,-1),
         ifelse(x >= -1 & x <  1, 0.1*dunif(x,-1, 1),
                ifelse(x >=  1 & x <  4, 0.3*dunif(x, 1, 4), 
                       0)))
}

dtnorm_mix1 = function(x)
{
  ifelse(x < 0 | x > 10, 
         0, 
         ( 0.5*dnorm(x,mean=2,sd=2)
           +0.5*dnorm(x,mean=6,sd=1))/0.9206407)
}

dtnorm_mix2 = function(x)
{
  ifelse(x < -4 | x > 4, 
         0, 
         ( 0.45*dnorm(x,mean=-4)
           +0.45*dnorm(x,mean= 4)
           +0.1 *dnorm(x,mean= 0,sd=0.5))/0.55)
}

score = function(x, dfunc) 
{
  stopifnot(is.numeric(x) & length(x))
  
  x = sort(x)
  n = length(x)

  ex = ecdf(x)(x)

  dx = dfunc(x)
  ed = cumsum(c(0, (x[-1]-x[-n])*(dx[-1]+dx[-n])/2))
  
  return( sqrt(sum((ex-ed)^2)/n) )
}

accuracy.df <- as.data.frame(matrix(rep(0,6), ncol=1))
names(accuracy.df) <- c("MC Score")
reject(1000000, dbetann, c(0,1), mc=TRUE)
reject(1000000, dtnorm, c(-3,3), mc=TRUE)
reject(1000000, dtexp, c(0,7), mc=TRUE)
reject(1000000, dtnorm_mix1, c(0,10), mc=TRUE)
reject(1000000, dtnorm_mix2, c(-4,4), mc=TRUE)

accuracy.df[1,1] <- score(reject(1000000, dbetann, c(0,1), mc=TRUE), dbetann) # 0.0000821
accuracy.df[2,1] <- score(reject(1000000, dtnorm, c(-3,3), mc=TRUE), dtnorm) # 0.0000821
accuracy.df[3,1] <- score(reject(1000000, dtexp, c(0,7), mc=TRUE), dtexp) # 0.000587
accuracy.df[4,1] <- score(reject(1000000, dunif_mix, c(-3,4), mc=TRUE), dunif_mix) # 0.000671
accuracy.df[5,1] <- score(reject(1000000, dtnorm_mix1, c(0,10), mc=TRUE), dtnorm_mix1) # 0.000399
accuracy.df[6,1] <- score(reject(1000000, dtnorm_mix2, c(-4,4), mc=TRUE), dtnorm_mix2) # 0.000419
accuracy.df
print(xtable(accuracy.df), comments = F, type = "html")
```

The rejection sampler had good accuracy.

### Metropolis-Hastings Sampler
### Slice Sampler
### R Sampler

```{r}

```