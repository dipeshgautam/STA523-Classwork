---
title: "README"
author: "Team2"
date: "11/6/2014"
output: html_document
---

One of our programming goals is to write faster R code. One way to achieve this aim is to avoid "for" loops so more time is spent on computation rather than on loops that process one element per iteration and copy data. Vectorized functions like the `apply` family were used, among other solutions, were devised to avoid `for` loops.



```{r eval=FALSE}
sum(sapply(sapply(graph3, "[[", 1), length)) # Step 1
sum(sapply(sapply(graph3, "[[", 2), length)) # Step 2
sum(sapply(sapply(graph1, "[[", 1), length)) == sum(sapply(sapply(graph1, "[[", 2), length)) # Step 3
```


```{r eval=FALSE}

for (v in 1:length(graph4) ) {
  visited <- c(visited, graph4[[v]]$edges)
  if (any(graph4[[v]]$edges %in% visited)) {
    print("Found loop.")
    return(TRUE)
  }
  for (e in g[[v]]$edges) { # I have a new edge and want to traverse it.
    if (traverse(g, e, visited)) # Going to new vertex e, and keeping track of "visited"
      return(TRUE) # Found a loop. Exit if().
  }
  return(FALSE) # If I haven't found a loop above, there is no loop.
}

```

###Method for Shortest Path and Minimum Spanning Trees:

Our method for finding the shortest path and minimum spanning trees are very similar. The functions for both create a power-set of all of the possible combinations of names in the graph. It then computes all of the different permutations of each power-set and filters on the ones that match the first and last vertices given. With this, each of the paths is verified, and if it is a valid path in the graph, the weights and edges are stored. For shortest path, the path with the minimum weight is returned. For minimum spanning trees, the function goes through every combination of first and last indices, and then checks to see which of the valid paths that are returned match the number of vertices. The minimum weight is then calculated and the graph of this path is returned.

This method, however, is inefficient for graphs with a large number of vertices because the total number of paths computed is equal the sum from r=1 to n of (n!/ (n-r)!), where n is the total number of items in the list of vertices.